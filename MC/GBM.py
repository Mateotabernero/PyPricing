# Posibles problemas:
# Las simulaciones de milstein parecen ser más altas. bueno creo que ha sido solo casualidad. He hecho 1000 simulaciones de euler y 1000 de milstein (mirar últimas líneas) y las medias en 250 eran 52.5038 (Euler), 52.4973 (Milstein) 
# Otroas simulaciones dan  53.0484 (Euler), 52.0673 (Milstein), 52.5674 (Rudge-kutta) 
import numpy as np 
import matplotlib.pyplot as plt 
import math 
import helpFunctions

# Space inefficient, but allows for an easier treatment of more general (path-dependent) payoffs 

def GBM(r, sigma, S_0, num_steps, T, num_simulations = 10000, integration_method = 'E', ant_variates = False):
    delta_t = T/num_steps 

    S = np.zeros((num_simulations, num_steps +1))
    W = np.random.normal(0,1,(num_simulations, num_steps)) 


    for i in range(num_simulations):
        S[i,0] = S_0 
    
    if ant_variates: 
        ant_S = S 
   
    for i in range(num_simulations):
        for j in range(num_steps): 
            # This values are common to the three methods of integration 

            deterministic_term = r*S[i,j]*delta_t
            random_term = sigma*S[i,j]*(math.sqrt(delta_t)*W[i,j])

            if ant_variates :
                ant_deterministic_term = r*ant_S[i,j]*delta_t 
                ant_random_term  = sigma*ant_S[i,j]*(-math.sqrt(delta_t)*W[i,j]) 
            
            if integration_method == 'E': 
                S[i,j+1] = S[i,j] + deterministic_term + random_term
                
                if ant_variates:
                    ant_S[i,j+1] = ant_S[i,j] + ant_deterministic_term + ant_random_term
            
            elif integration_method == 'M':
                milstein_term = 1/2 * (sigma**2)*S[i,j]*((math.sqrt(delta_t)*W[i,j])**2 - delta_t)
                S[i,j+1] = S[i,j] + deterministic_term + random_term + milstein_term
                
                if ant_variates:
                    ant_milstein_term = 1/2 * (sigma**2)*ant_S[i,j]*((-math.sqrt(delta_t)*W[i,j])**2 - delta_t)
                    ant_S[i,j+1] = ant_S[i,j] + ant_deterministic_term + ant_random_term + ant_milstein_term
        
            elif integration_method == 'RK': 
                y_hat = S[i,j] + r*S[i,j]*delta_t + sigma*math.sqrt(delta_t) 
                rk_term = ((math.sqrt(delta_t)*W[i,j])**2 - delta_t) * sigma*(y_hat - S[i,j]) /(2*math.sqrt(delta_t))
                S[i, j+1] = S[i,j] + deterministic_term + random_term + rk_term 

                if ant_variates:
                    ant_y_hat =  ant_S[i,j] + r*ant_S[i,j]*delta_t + sigma*math.sqrt(delta_t)
                    ant_rk_term =((-math.sqrt(delta_t)*W[i,j])**2 - delta_t) * sigma*(ant_y_hat - ant_S[i,j]) /(2*math.sqrt(delta_t))
                    ant_S[i,j+1] = ant_S[i,j] + ant_deterministic_term + ant_random_term + ant_rk_term
            
            else: 
                raise ValueError ("Please choose an appropiate SDE integration method (Euler ('E'), Milstein ('M') or Rudge-Kutta ('RK'))")
    
    if ant_variates:
        # Hay qeu mirar como append esto
        return (S, ant_S)
    
    return S
    

#This function uses the paths generated by the previous function to price european options through 
def eu_GBM(r, sigma, S_0, K, num_steps, T, put_or_call, num_simulations = 10000, integration_method = 'E', ant_variates = False, payOff = helpFunctions.payOff): 
    S = GBM(r, sigma, S_0, num_steps, T, num_simulations = num_simulations, integration_method = 'E', ant_variates = False)
    Vs = np.vectorize(payOff) (S[:, num_steps], K, put_or_call)
    V = math.exp(-r*T)*np.mean(Vs) 
    return V 

def as_GBM(r, sigma, S_0, K, num_steps, T, put_or_call, num_simulations = 10000, integration_method = 'E', ant_variates = False, payOff = helpFunctions.asianPayOff):
    S = GBM(r, sigma, S_0, num_steps, T, num_simulations = num_simulations, integration_method = 'E', ant_variates = False)
    # Hay que definir mejor la media porque seguro que hay una forma mucho mejor 
    price_mean = np.zeros(num_simulations)
    for i in range(num_simulations):
        price_mean[i] = np.mean(S[i,:]) 
    Vs = np.vectorize(payOff)(S[:, num_steps], K, price_mean, put_or_call)
    # Y supongo que luego hay que hacer lo mismo que con las europeas pero debería comprobarlo
    V = math.exp(-r*T)*np.mean(Vs) 
    return V 

#Habría que añadir más payoffs. El vanilla es el más normal pero tampoco cuesta mucho. Es cambiar la fórmula payOff añadiendo un nuevo parámetro que sea predefinido como 'Vanilla'
# Adaptarlo para up-and-out barriers requiere modificar un poco así que se puede hacer una función diferente. SI el precio sube por encima de la barrera hay que dejar claro que la opción no se ejecuta y el payoff será cero  
# Definir otra función que sea up_out_eu_GBM y luego poner un if que si el payoff es ese se llame a esa función

def eu_cir_GBM (r_0, sigma, S_0, K, R, sigma_r, num_steps, T, put_or_call, num_simulations = 10000, integration = 'E', ant_variates = False, cir_integration = 'E', cir_ant_variates = False):

    # Esta función la tengo definida en el portátil 

    (S,r) = cir_GBM(r_0, sigma, S_0, sigma_r, num_steps,T, cir_integration, cir_ant_variates) 
    
    # Lo que viene ahora se puede hacer mejor vectorizando np.mean o algo así seguro
    
    average_r = np.zeros(num_simulations)
    for i in range(num_simulations):
        average_r[i] = np.mean(r[i, :])

    Vs = np.zeros (num_simulations)  
    for i in range(i):
        #esto creo que es correcto, cogemos la media de las r para cada valor y luego tomamos medias.
        Vs[i] = math.exp(-r[i]*T) *payOff(S[i, num_steps], K, put_or_call) 
    
    V = np.mean(Vs) 
    return V 
